<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CdcAndWzj&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2026-01-21T14:15:46.960Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>CdcAndWzj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python的__init__文件</title>
    <link href="http://example.com/2026/01/21/python-1/"/>
    <id>http://example.com/2026/01/21/python-1/</id>
    <published>2026-01-21T13:07:53.000Z</published>
    <updated>2026-01-21T14:15:46.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-init-py-的核心作用"><a href="#1-init-py-的核心作用" class="headerlink" title="1. __init__.py 的核心作用"></a>1. <code>__init__.py</code> 的核心作用</h2><p>在 Python 中，包含 <code>__init__.py</code> 文件的目录被视为一个 <strong>Package（包）</strong>。</p><ul><li><strong>标识作用</strong>：告诉 Python 解释器这个目录不仅仅是文件夹，而是一个可导入的包。</li><li><strong>初始化代码</strong>：当包被导入时，<code>__init__.py</code> 中的代码会自动执行（且仅执行一次）。</li></ul><hr><h2 id="2-all-详解"><a href="#2-all-详解" class="headerlink" title="2. __all__ 详解"></a>2. <code>__all__</code> 详解</h2><p><code>__all__</code> 是一个字符串列表，用于控制 <code>from package import *</code> 的行为。</p><ul><li><strong>作用</strong>：当你使用 <code>from package import *</code> 时，只有在 <code>__all__</code> 列表中列出的变量、函数或类会被导入到当前的命名空间。</li><li><strong>最佳实践</strong>：如果不定义 <code>__all__</code>，默认会导入模块中所有不以下划线 <code>_</code> 开头的名称。显式定义 <code>__all__</code> 可以避免污染用户的命名空间，隐藏内部实现细节。</li></ul><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件：mypackage/__init__.py</span></span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;PublicClass&#x27;</span>, <span class="string">&#x27;public_func&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublicClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">public_func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_internal_func</span>():</span><br><span class="line">    <span class="comment"># 这个函数不会被 &#x27;from mypackage import *&#x27; 导入</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-Import-功能详解：如何设计优雅的-API接口"><a href="#3-Import-功能详解：如何设计优雅的-API接口" class="headerlink" title="3. Import 功能详解：如何设计优雅的 API接口"></a>3. Import 功能详解：如何设计优雅的 API接口</h2><p><em>(参考自 Geek-Docs: How do I write good&#x2F;correct package <strong>init</strong>.py files)</em></p><p><code>__init__.py</code> 最强大的功能之一是<strong>组织和简化包的导入接口</strong>。通过在 <code>__init__.py</code> 中精心设计 import 语句，可以向用户提供更友好的访问方式。</p><h3 id="A-提升命名空间-Hoisting-便捷导入"><a href="#A-提升命名空间-Hoisting-便捷导入" class="headerlink" title="A. 提升命名空间 (Hoisting) &#x2F; 便捷导入"></a>A. 提升命名空间 (Hoisting) &#x2F; 便捷导入</h3><p>通常，我们的代码逻辑分散在包内的不同子模块中。如果不处理，用户导入时需要写很长的路径。我们可以在 <code>__init__.py</code> 中将核心类或函数导入，使其对外暴露在包的顶层。</p><p><strong>场景假设：</strong><br>目录结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mypackage/</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── database.py  &lt;-- 里面定义了 Database 类</span><br><span class="line">    └── network.py   &lt;-- 里面定义了 Connect 函数</span><br></pre></td></tr></table></figure><p><strong>不好的体验（如果不配置 <code>__init__.py</code>）：</strong><br>用户必须这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mypackage.database</span><br><span class="line"><span class="keyword">import</span> mypackage.network</span><br><span class="line"></span><br><span class="line">db = mypackage.database.Database()</span><br><span class="line">conn = mypackage.network.Connect()</span><br></pre></td></tr></table></figure><p><strong>优雅的体验（在 <code>__init__.py</code> 中配置）：</strong></p><p>在 <code>mypackage/__init__.py</code> 中写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用相对导入，将子模块的内容引入到当前包的命名空间</span></span><br><span class="line"><span class="keyword">from</span> .database <span class="keyword">import</span> Database</span><br><span class="line"><span class="keyword">from</span> .network <span class="keyword">import</span> Connect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配合 __all__ 使用，明确导出的接口</span></span><br><span class="line">__all__ = [<span class="string">&#x27;Database&#x27;</span>, <span class="string">&#x27;Connect&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>用户现在可以这样写：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mypackage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接通过包名访问，无需知道内部文件结构</span></span><br><span class="line">db = mypackage.Database()</span><br><span class="line">conn = mypackage.Connect()</span><br></pre></td></tr></table></figure><h3 id="B-区分“接口”与“实现”"><a href="#B-区分“接口”与“实现”" class="headerlink" title="B. 区分“接口”与“实现”"></a>B. 区分“接口”与“实现”</h3><p>通过在 <code>__init__.py</code> 中控制 import，你可以重构内部文件的结构（例如把一个大文件拆分成五个小文件），但只要 <code>__init__.py</code> 暴露的接口不变，使用你代码的用户就不需要修改任何代码。</p><h3 id="C-处理包级别的初始化"><a href="#C-处理包级别的初始化" class="headerlink" title="C. 处理包级别的初始化"></a>C. 处理包级别的初始化</h3><p>你可以在 <code>__init__.py</code> 中导入必要的依赖或设置全局配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mypackage/__init__.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查环境变量配置</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.getenv(<span class="string">&quot;API_KEY&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Warning: API_KEY not set&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露核心类</span></span><br><span class="line"><span class="keyword">from</span> .core <span class="keyword">import</span> MainService</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-init-py-的核心作用&quot;&gt;&lt;a href=&quot;#1-init-py-的核心作用&quot; class=&quot;headerlink&quot; title=&quot;1. __init__.py 的核心作用&quot;&gt;&lt;/a&gt;1. &lt;code&gt;__init__.py&lt;/code&gt; 的核心作用&lt;/h</summary>
      
    
    
    
    
  </entry>
  
</feed>
