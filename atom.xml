<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>CdcAndWzj&#39;s Blog</title>
  
  
  <link href="https://prose2077.github.io/atom.xml" rel="self"/>
  
  <link href="https://prose2077.github.io/"/>
  <updated>2026-01-22T08:40:10.533Z</updated>
  <id>https://prose2077.github.io/</id>
  
  <author>
    <name>CdcAndWzj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VS Code 遇到的 No module named 问题</title>
    <link href="https://prose2077.github.io/2026/01/22/vscode_and_python/"/>
    <id>https://prose2077.github.io/2026/01/22/vscode_and_python/</id>
    <published>2026-01-22T03:50:15.502Z</published>
    <updated>2026-01-22T08:40:10.533Z</updated>
    
    <content type="html"><![CDATA[<p>VS Code 这个“万金油”是我非常喜欢的编辑器，然而在用它写 Python 项目时，经常会出现 <code>ModuleNotFoundError: No module named &#39;xxx&#39;</code> 的情况。</p><p>这里的 <code>xxx</code> 一般是自己写的模块（第三方库通常已在 Python 默认路径中）。出现这个问题，通常是因为 <strong>Python 解释器不知道去哪里找你写的代码</strong>。</p><h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>假设你的项目目录结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ProjectRoot/</span><br><span class="line">├── utils/</span><br><span class="line">│   └── helper.py</span><br><span class="line">└── src/</span><br><span class="line">    └── main.py</span><br></pre></td></tr></table></figure><p>当你在 <code>ProjectRoot</code> 根目录下打开 VS Code，并在终端运行 <code>src/main.py</code> 时，如果不做配置，Python 往往无法在 <code>main.py</code> 中引用 <code>utils.helper</code>，因为它找不到 <code>utils</code> 文件夹。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="方法一：修改-settings-json（亲测有效）"><a href="#方法一：修改-settings-json（亲测有效）" class="headerlink" title="方法一：修改 settings.json（亲测有效）"></a>方法一：修改 settings.json（亲测有效）</h4><p>这是一个简单粗暴且有效的方法。通过配置 VS Code 的终端环境，强制将项目根目录加入到 Python 的搜索路径中。<br><strong>步骤：</strong></p><ol><li><p><code>Ctrl + Shift + P</code> 打开命令面板，输入 <code>Preferences: Open Settings (JSON)</code>（首选项：打开设置(JSON)）。<br><img src="/images/vscode%E6%89%93%E5%BC%80setting-json.png" alt="图片" title="Setting.json"></p></li><li><p>在 JSON 文件的大括号 <code>{ ... }</code> 中加入以下配置：<br><img src="/images/python%E5%8A%A0%E5%85%A5%E5%B7%A5%E4%BD%9C%E5%8C%BA.png" alt="图片" title="Setting-2.json"></p></li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;terminal.integrated.env.osx&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;PYTHONPATH&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;terminal.integrated.env.linux&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;PYTHONPATH&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;terminal.integrated.env.windows&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;PYTHONPATH&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>原理（先来段AI解释）：</strong></p><ol><li><p><strong>配置项作用</strong>：</p><ul><li><code>terminal.integrated.env.*</code>: 针对不同操作系统（macOS&#x2F;Linux&#x2F;Windows），为 VS Code 的<strong>集成终端</strong>设置环境变量。</li><li>这确保了无论你在什么系统上开发，只要在 VS Code 终端里跑 Python，这个环境变量都会生效。</li></ul></li><li><p><strong>设置的内容</strong>：</p><ul><li><code>&quot;PYTHONPATH&quot;: &quot;${workspaceFolder}&quot;</code>：<ul><li><code>PYTHONPATH</code>：这是一个经典的环境变量。Python 解释器在启动时，会先把这个变量里指定的路径加入到搜索列表中。</li><li><code>&quot;${workspaceFolder}&quot;</code>：这是 VS Code 的预定义变量，代表<strong>当前打开项目的根目录绝对路径</strong>。</li></ul></li></ul></li></ol><p><strong>简单来说（人话）</strong>：就是让Python把我整个项目的根目录（其实是vscode打开的目录）也作为搜索代码的地方</p><hr><h4 id="方法二：使用-env-文件（这个没试过）"><a href="#方法二：使用-env-文件（这个没试过）" class="headerlink" title="方法二：使用 .env 文件（这个没试过）"></a>方法二：使用 .env 文件（这个没试过）</h4><p>如果补想污染全局配置，或者希望配置能跟随项目代码（Git）走，可以使用 <code>.env</code> 文件。VS Code 的 Python 插件会自动读取该文件。</p><ol><li>在项目根目录下创建一个名为 <code>.env</code> 的文件。</li><li>在里面写入：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PYTHONPATH=.</span><br></pre></td></tr></table></figure></li><li>确保你的 <code>settings.json</code> 中有如下配置（默认通常就是开启的）：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;python.envFile&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;/.env&quot;</span></span><br></pre></td></tr></table></figure>这样不仅终端运行有效，调试器（Debugger）启动时也会自动生效。</li></ol><hr><h3 id="Python-的搜寻路径-原理深入"><a href="#Python-的搜寻路径-原理深入" class="headerlink" title="Python 的搜寻路径 (原理深入)"></a>Python 的搜寻路径 (原理深入)</h3><p>为什么会出现这个问题？这需要理解 Python 查找模块的逻辑（<code>sys.path</code>）。</p><p>当你执行 <code>python src/main.py</code> 时，Python 的搜索路径顺序通常如下：</p><ol><li><strong>当前脚本所在的目录</strong>：即 <code>src/</code> 目录。（注意：<strong>不是</strong>你运行命令的 <code>ProjectRoot</code> 目录！）</li><li><strong>PYTHONPATH 环境变量</strong>：我们在上面配置的就是这一项。</li><li><strong>标准库目录</strong>：安装 Python 时自带的库（如 <code>os</code>, <code>sys</code> 等）。</li><li><strong>第三方库目录 (site-packages)</strong>：你用 <code>pip install</code> 安装的库都在这里。</li></ol><p><strong>问题根源：</strong><br>因为默认情况下，Python 只把 <code>src/</code> 加入了路径。当你代码里写 <code>from utils import helper</code> 时，Python 在 <code>src/</code> 目录下找不到 <code>utils</code> 文件夹（因为它在上一级），于是就报错 <code>No module named</code>。</p><p>通过设置 <code>PYTHONPATH</code> 为项目根目录，Python 就能顺利在根目录下找到 <code>utils</code> 文件夹了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;VS Code 这个“万金油”是我非常喜欢的编辑器，然而在用它写 Python 项目时，经常会出现 &lt;code&gt;ModuleNotFoundError: No module named &amp;#39;xxx&amp;#39;&lt;/code&gt; 的情况。&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;x</summary>
      
    
    
    
    
    <category term="Python" scheme="https://prose2077.github.io/tags/Python/"/>
    
    <category term="vscode" scheme="https://prose2077.github.io/tags/vscode/"/>
    
    <category term="经验分享" scheme="https://prose2077.github.io/tags/%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>python的__init__文件</title>
    <link href="https://prose2077.github.io/2026/01/21/python-1/"/>
    <id>https://prose2077.github.io/2026/01/21/python-1/</id>
    <published>2026-01-21T13:07:53.000Z</published>
    <updated>2026-01-22T09:01:52.291Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-init-py-的核心作用"><a href="#1-init-py-的核心作用" class="headerlink" title="1. __init__.py 的核心作用"></a>1. <code>__init__.py</code> 的核心作用</h2><p>在 Python 中，包含 <code>__init__.py</code> 文件的目录被视为一个 <strong>Package（包）</strong>。</p><ul><li><strong>标识作用</strong>：告诉 Python 解释器这个目录不仅仅是文件夹，而是一个可导入的包。</li><li><strong>初始化代码</strong>：当包被导入时，<code>__init__.py</code> 中的代码会自动执行（且仅执行一次）。</li></ul><hr><h2 id="2-all-详解"><a href="#2-all-详解" class="headerlink" title="2. __all__ 详解"></a>2. <code>__all__</code> 详解</h2><p><code>__all__</code> 是一个字符串列表，用于控制 <code>from package import *</code> 的行为。</p><ul><li><strong>作用</strong>：当你使用 <code>from package import *</code> 时，只有在 <code>__all__</code> 列表中列出的变量、函数或类会被导入到当前的命名空间。</li><li><strong>最佳实践</strong>：如果不定义 <code>__all__</code>，默认会导入模块中所有不以下划线 <code>_</code> 开头的名称。显式定义 <code>__all__</code> 可以避免污染用户的命名空间，隐藏内部实现细节。</li></ul><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件：mypackage/__init__.py</span></span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">&#x27;PublicClass&#x27;</span>, <span class="string">&#x27;public_func&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PublicClass</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">public_func</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_internal_func</span>():</span><br><span class="line">    <span class="comment"># 这个函数不会被 &#x27;from mypackage import *&#x27; 导入</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><hr><h2 id="3-Import-功能详解：如何设计优雅的-API接口"><a href="#3-Import-功能详解：如何设计优雅的-API接口" class="headerlink" title="3. Import 功能详解：如何设计优雅的 API接口"></a>3. Import 功能详解：如何设计优雅的 API接口</h2><p><em>(参考自 Geek-Docs: How do I write good&#x2F;correct package <strong>init</strong>.py files)</em></p><p><code>__init__.py</code> 最强大的功能之一是<strong>组织和简化包的导入接口</strong>。通过在 <code>__init__.py</code> 中精心设计 import 语句，可以向用户提供更友好的访问方式。</p><h3 id="A-提升命名空间-Hoisting-便捷导入"><a href="#A-提升命名空间-Hoisting-便捷导入" class="headerlink" title="A. 提升命名空间 (Hoisting) &#x2F; 便捷导入"></a>A. 提升命名空间 (Hoisting) &#x2F; 便捷导入</h3><p>通常，我们的代码逻辑分散在包内的不同子模块中。如果不处理，用户导入时需要写很长的路径。我们可以在 <code>__init__.py</code> 中将核心类或函数导入，使其对外暴露在包的顶层。</p><p><strong>场景假设：</strong><br>目录结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mypackage/</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── database.py  &lt;-- 里面定义了 Database 类</span><br><span class="line">    └── network.py   &lt;-- 里面定义了 Connect 函数</span><br></pre></td></tr></table></figure><p><strong>不好的体验（如果不配置 <code>__init__.py</code>）：</strong><br>用户必须这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mypackage.database</span><br><span class="line"><span class="keyword">import</span> mypackage.network</span><br><span class="line"></span><br><span class="line">db = mypackage.database.Database()</span><br><span class="line">conn = mypackage.network.Connect()</span><br></pre></td></tr></table></figure><p><strong>优雅的体验（在 <code>__init__.py</code> 中配置）：</strong></p><p>在 <code>mypackage/__init__.py</code> 中写入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用相对导入，将子模块的内容引入到当前包的命名空间</span></span><br><span class="line"><span class="keyword">from</span> .database <span class="keyword">import</span> Database</span><br><span class="line"><span class="keyword">from</span> .network <span class="keyword">import</span> Connect</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配合 __all__ 使用，明确导出的接口</span></span><br><span class="line">__all__ = [<span class="string">&#x27;Database&#x27;</span>, <span class="string">&#x27;Connect&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>用户现在可以这样写：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> mypackage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接通过包名访问，无需知道内部文件结构</span></span><br><span class="line">db = mypackage.Database()</span><br><span class="line">conn = mypackage.Connect()</span><br></pre></td></tr></table></figure><h3 id="B-区分“接口”与“实现”"><a href="#B-区分“接口”与“实现”" class="headerlink" title="B. 区分“接口”与“实现”"></a>B. 区分“接口”与“实现”</h3><p>通过在 <code>__init__.py</code> 中控制 import，你可以重构内部文件的结构（例如把一个大文件拆分成五个小文件），但只要 <code>__init__.py</code> 暴露的接口不变，使用你代码的用户就不需要修改任何代码。</p><h3 id="C-处理包级别的初始化"><a href="#C-处理包级别的初始化" class="headerlink" title="C. 处理包级别的初始化"></a>C. 处理包级别的初始化</h3><p>你可以在 <code>__init__.py</code> 中导入必要的依赖或设置全局配置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mypackage/__init__.py</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查环境变量配置</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.getenv(<span class="string">&quot;API_KEY&quot;</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Warning: API_KEY not set&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 暴露核心类</span></span><br><span class="line"><span class="keyword">from</span> .core <span class="keyword">import</span> MainService</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-init-py-的核心作用&quot;&gt;&lt;a href=&quot;#1-init-py-的核心作用&quot; class=&quot;headerlink&quot; title=&quot;1. __init__.py 的核心作用&quot;&gt;&lt;/a&gt;1. &lt;code&gt;__init__.py&lt;/code&gt; 的核心作用&lt;/h</summary>
      
    
    
    
    
  </entry>
  
</feed>
