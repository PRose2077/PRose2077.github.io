[{"title":"python的__init__文件","path":"/2026/01/21/python-1/","content":"1. __init__.py 的核心作用在 Python 中，包含 __init__.py 文件的目录被视为一个 Package（包）。 标识作用：告诉 Python 解释器这个目录不仅仅是文件夹，而是一个可导入的包。 初始化代码：当包被导入时，__init__.py 中的代码会自动执行（且仅执行一次）。 2. __all__ 详解__all__ 是一个字符串列表，用于控制 from package import * 的行为。 作用：当你使用 from package import * 时，只有在 __all__ 列表中列出的变量、函数或类会被导入到当前的命名空间。 最佳实践：如果不定义 __all__，默认会导入模块中所有不以下划线 _ 开头的名称。显式定义 __all__ 可以避免污染用户的命名空间，隐藏内部实现细节。 示例： # 文件：mypackage/__init__.py__all__ = [PublicClass, public_func]class PublicClass: passdef public_func(): passdef _internal_func(): # 这个函数不会被 from mypackage import * 导入 pass 3. Import 功能详解：如何设计优雅的 API接口(参考自 Geek-Docs: How do I write goodcorrect package init.py files) __init__.py 最强大的功能之一是组织和简化包的导入接口。通过在 __init__.py 中精心设计 import 语句，可以向用户提供更友好的访问方式。 A. 提升命名空间 (Hoisting) 便捷导入通常，我们的代码逻辑分散在包内的不同子模块中。如果不处理，用户导入时需要写很长的路径。我们可以在 __init__.py 中将核心类或函数导入，使其对外暴露在包的顶层。 场景假设：目录结构如下： mypackage/ ├── __init__.py ├── database.py -- 里面定义了 Database 类 └── network.py -- 里面定义了 Connect 函数 不好的体验（如果不配置 __init__.py）：用户必须这样写： import mypackage.databaseimport mypackage.networkdb = mypackage.database.Database()conn = mypackage.network.Connect() 优雅的体验（在 __init__.py 中配置）： 在 mypackage/__init__.py 中写入： # 使用相对导入，将子模块的内容引入到当前包的命名空间from .database import Databasefrom .network import Connect# 配合 __all__ 使用，明确导出的接口__all__ = [Database, Connect] 用户现在可以这样写： import mypackage# 直接通过包名访问，无需知道内部文件结构db = mypackage.Database()conn = mypackage.Connect() B. 区分“接口”与“实现”通过在 __init__.py 中控制 import，你可以重构内部文件的结构（例如把一个大文件拆分成五个小文件），但只要 __init__.py 暴露的接口不变，使用你代码的用户就不需要修改任何代码。 C. 处理包级别的初始化你可以在 __init__.py 中导入必要的依赖或设置全局配置。 # mypackage/__init__.pyimport os# 检查环境变量配置if not os.getenv(API_KEY): print(Warning: API_KEY not set)# 暴露核心类from .core import MainService"}]