[{"title":"VS Code 遇到的 No module named 问题","path":"/2026/01/22/vscode_and_python/","content":"VS Code 这个“万金油”是我非常喜欢的编辑器，然而在用它写 Python 项目时，经常会出现 ModuleNotFoundError: No module named xxx 的情况。 这里的 xxx 一般是自己写的模块（第三方库通常已在 Python 默认路径中）。出现这个问题，通常是因为 Python 解释器不知道去哪里找你写的代码。 问题场景假设你的项目目录结构如下： ProjectRoot/├── utils/│ └── helper.py└── src/ └── main.py 当你在 ProjectRoot 根目录下打开 VS Code，并在终端运行 src/main.py 时，如果不做配置，Python 往往无法在 main.py 中引用 utils.helper，因为它找不到 utils 文件夹。 解决方案方法一：修改 settings.json（亲测有效）这是一个简单粗暴且有效的方法。通过配置 VS Code 的终端环境，强制将项目根目录加入到 Python 的搜索路径中。步骤： Ctrl + Shift + P 打开命令面板，输入 Preferences: Open Settings (JSON)（首选项：打开设置(JSON)）。 在 JSON 文件的大括号 { ... } 中加入以下配置： terminal.integrated.env.osx: PYTHONPATH: $workspaceFolder,terminal.integrated.env.linux: PYTHONPATH: $workspaceFolder,terminal.integrated.env.windows: PYTHONPATH: $workspaceFolder 原理（先来段AI解释）： 配置项作用： terminal.integrated.env.*: 针对不同操作系统（macOSLinuxWindows），为 VS Code 的集成终端设置环境变量。 这确保了无论你在什么系统上开发，只要在 VS Code 终端里跑 Python，这个环境变量都会生效。 设置的内容： PYTHONPATH: ${workspaceFolder}： PYTHONPATH：这是一个经典的环境变量。Python 解释器在启动时，会先把这个变量里指定的路径加入到搜索列表中。 ${workspaceFolder}：这是 VS Code 的预定义变量，代表当前打开项目的根目录绝对路径。 简单来说（人话）：就是让Python把我整个项目的根目录（其实是vscode打开的目录）也作为搜索代码的地方 方法二：使用 .env 文件（这个没试过）如果补想污染全局配置，或者希望配置能跟随项目代码（Git）走，可以使用 .env 文件。VS Code 的 Python 插件会自动读取该文件。 在项目根目录下创建一个名为 .env 的文件。 在里面写入：PYTHONPATH=. 确保你的 settings.json 中有如下配置（默认通常就是开启的）：python.envFile: $workspaceFolder/.env 这样不仅终端运行有效，调试器（Debugger）启动时也会自动生效。 Python 的搜寻路径 (原理深入)为什么会出现这个问题？这需要理解 Python 查找模块的逻辑（sys.path）。 当你执行 python src/main.py 时，Python 的搜索路径顺序通常如下： 当前脚本所在的目录：即 src/ 目录。（注意：不是你运行命令的 ProjectRoot 目录！） PYTHONPATH 环境变量：我们在上面配置的就是这一项。 标准库目录：安装 Python 时自带的库（如 os, sys 等）。 第三方库目录 (site-packages)：你用 pip install 安装的库都在这里。 问题根源：因为默认情况下，Python 只把 src/ 加入了路径。当你代码里写 from utils import helper 时，Python 在 src/ 目录下找不到 utils 文件夹（因为它在上一级），于是就报错 No module named。 通过设置 PYTHONPATH 为项目根目录，Python 就能顺利在根目录下找到 utils 文件夹了。","tags":["Python, vscode, 经验分享`"]},{"title":"python的__init__文件","path":"/2026/01/21/python-1/","content":"1. __init__.py 的核心作用在 Python 中，包含 __init__.py 文件的目录被视为一个 Package（包）。 标识作用：告诉 Python 解释器这个目录不仅仅是文件夹，而是一个可导入的包。 初始化代码：当包被导入时，__init__.py 中的代码会自动执行（且仅执行一次）。 2. __all__ 详解__all__ 是一个字符串列表，用于控制 from package import * 的行为。 作用：当你使用 from package import * 时，只有在 __all__ 列表中列出的变量、函数或类会被导入到当前的命名空间。 最佳实践：如果不定义 __all__，默认会导入模块中所有不以下划线 _ 开头的名称。显式定义 __all__ 可以避免污染用户的命名空间，隐藏内部实现细节。 示例： # 文件：mypackage/__init__.py__all__ = [PublicClass, public_func]class PublicClass: passdef public_func(): passdef _internal_func(): # 这个函数不会被 from mypackage import * 导入 pass 3. Import 功能详解：如何设计优雅的 API接口(参考自 Geek-Docs: How do I write goodcorrect package init.py files) __init__.py 最强大的功能之一是组织和简化包的导入接口。通过在 __init__.py 中精心设计 import 语句，可以向用户提供更友好的访问方式。 A. 提升命名空间 (Hoisting) 便捷导入通常，我们的代码逻辑分散在包内的不同子模块中。如果不处理，用户导入时需要写很长的路径。我们可以在 __init__.py 中将核心类或函数导入，使其对外暴露在包的顶层。 场景假设：目录结构如下： mypackage/ ├── __init__.py ├── database.py -- 里面定义了 Database 类 └── network.py -- 里面定义了 Connect 函数 不好的体验（如果不配置 __init__.py）：用户必须这样写： import mypackage.databaseimport mypackage.networkdb = mypackage.database.Database()conn = mypackage.network.Connect() 优雅的体验（在 __init__.py 中配置）： 在 mypackage/__init__.py 中写入： # 使用相对导入，将子模块的内容引入到当前包的命名空间from .database import Databasefrom .network import Connect# 配合 __all__ 使用，明确导出的接口__all__ = [Database, Connect] 用户现在可以这样写： import mypackage# 直接通过包名访问，无需知道内部文件结构db = mypackage.Database()conn = mypackage.Connect() B. 区分“接口”与“实现”通过在 __init__.py 中控制 import，你可以重构内部文件的结构（例如把一个大文件拆分成五个小文件），但只要 __init__.py 暴露的接口不变，使用你代码的用户就不需要修改任何代码。 C. 处理包级别的初始化你可以在 __init__.py 中导入必要的依赖或设置全局配置。 # mypackage/__init__.pyimport os# 检查环境变量配置if not os.getenv(API_KEY): print(Warning: API_KEY not set)# 暴露核心类from .core import MainService"}]